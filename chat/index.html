<!---------------

Chat P2P con Oferta y Respuesta Autom√°tica
Voy a crear un chat P2P que funcione completamente en el navegador usando WebRTC para la comunicaci√≥n peer-to-peer. El chat incluir√°:

Oferta y respuesta autom√°ticas
Gesti√≥n de contactos con IDs de dispositivo
Funcionalidad de chat y env√≠o de archivos
Almacenamiento local de mensajes y contactos
Aqu√≠ est√° el c√≥digo completo:

index.html
------->
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat P2P Auto</title>
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs/qrcode.min.js"></script>
  <script src="script.js"></script>
  
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      margin: 0;
      padding: 20px;
      color: #fff;
      min-height: 100vh;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }

    header {
      background: linear-gradient(to right, #4b6cb7, #182848);
      padding: 20px;
      text-align: center;
    }

    h1 {
      margin: 0;
      font-size: 2.2rem;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .status {
      background: #2c3e50;
      padding: 10px;
      text-align: center;
      font-weight: bold;
      color: #3498db;
    }

    .chat-container {
      display: flex;
      flex-direction: column;
      height: 500px;
    }

    .chat-box {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      background: rgba(30, 30, 40, 0.8);
    }

    .message {
      margin-bottom: 15px;
      padding: 12px 15px;
      border-radius: 10px;
      max-width: 70%;
      word-wrap: break-word;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .message.sent {
      background: linear-gradient(to right, #3498db, #2980b9);
      margin-left: auto;
      border-bottom-right-radius: 0;
    }

    .message.received {
      background: linear-gradient(to right, #2c3e50, #1a2530);
      margin-right: auto;
      border-bottom-left-radius: 0;
    }

    .message .timestamp {
      font-size: 0.7rem;
      opacity: 0.8;
      margin-top: 5px;
      display: block;
    }

    .input-area {
      display: flex;
      padding: 15px;
      background: #2c3e50;
    }

    #messageInput {
      flex: 1;
      padding: 12px 15px;
      border: none;
      border-radius: 25px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 1rem;
      outline: none;
    }

    #messageInput::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    #sendButton {
      margin-left: 10px;
      padding: 12px 20px;
      background: linear-gradient(to right, #3498db, #2980b9);
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
    }

    #sendButton:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    .contact-section {
      padding: 20px;
      background: rgba(40, 40, 60, 0.8);
    }

    .contact-section h2 {
      margin-top: 0;
      color: #3498db;
    }

    .contact-list {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 10px;
    }

    .contact-item {
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      margin-bottom: 5px;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .contact-info {
      flex: 1;
    }

    .contact-name {
      font-weight: bold;
    }

    .contact-id {
      font-size: 0.8rem;
      opacity: 0.7;
    }

    .contact-actions button {
      background: #e74c3c;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
      margin-left: 5px;
    }

    .contact-actions button:hover {
      background: #c0392b;
    }

    .file-section {
      padding: 15px;
      background: rgba(40, 40, 60, 0.8);
      display: flex;
      align-items: center;
    }

    #fileInput {
      margin-right: 10px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 5px;
    }

    #sendFileButton {
      padding: 8px 15px;
      background: linear-gradient(to right, #2ecc71, #27ae60);
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #sendFileButton:hover {
      background: linear-gradient(to right, #27ae60, #219653);
    }

    .system-message {
      text-align: center;
      color: #f1c40f;
      font-style: italic;
      padding: 10px;
    }

    .connection-status {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 10px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-connected {
      background: #2ecc71;
    }

    .status-disconnected {
      background: #e74c3c;
    }

    .status-pending {
      background: #f1c40f;
    }

    .hidden {
      display: none;
    }

    .qr-section {
      padding: 20px;
      background: rgba(40, 40, 60, 0.8);
      text-align: center;
    }

    #qrCode {
      margin: 10px auto;
      width: 200px;
      height: 200px;
      background: white;
      padding: 10px;
      border-radius: 10px;
    }

    .qr-section h2 {
      margin-top: 0;
      color: #3498db;
    }

    .qr-section p {
      margin: 10px 0;
    }

    .btn {
      padding: 10px 20px;
      margin: 5px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }

    .btn-primary {
      background: linear-gradient(to right, #3498db, #2980b9);
      color: white;
    }

    .btn-secondary {
      background: linear-gradient(to right, #9b59b6, #8e44ad);
      color: white;
    }

    .btn-success {
      background: linear-gradient(to right, #2ecc71, #27ae60);
      color: white;
    }

    .btn-danger {
      background: linear-gradient(to right, #e74c3c, #c0392b);
      color: white;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
  </style>
  
</head>
<body>
  <div class="container">
    <header>
      <h1>Chat P2P Autom√°tico</h1>
    </header>
    
    <div class="status" id="connectionStatus">
      Esperando conexi√≥n...
    </div>
    
    <div class="chat-container">
      <div class="chat-box" id="chatBox">
        <div class="system-message">Bienvenido al chat P2P. Esperando conexi√≥n...</div>
      </div>
      
      <div class="input-area">
        <input type="text" id="messageInput" placeholder="Escribe tu mensaje..." />
        <button id="sendButton">Enviar</button>
      </div>
    </div>
    
    <div class="file-section">
      <input type="file" id="fileInput" />
      <button id="sendFileButton">Enviar Archivo</button>
    </div>
    
    <div class="contact-section">
      <h2>Contactos</h2>
      <div class="contact-list" id="contactList">
        <!-- Contactos se mostrar√°n aqu√≠ -->
      </div>
      <div class="input-area">
        <input type="text" id="newContactName" placeholder="Nombre del contacto" />
        <button id="addContactButton" class="btn btn-primary">Agregar Contacto</button>
      </div>
    </div>
    
    <div class="qr-section">
      <h2>Conexi√≥n P2P</h2>
      <p>Para conectar con otro usuario, comparte este c√≥digo QR o el texto de conexi√≥n:</p>
      <div id="qrCode"></div>
      <p id="connectionInfo">Generando conexi√≥n...</p>
      <div class="input-area">
        <input type="text" id="connectionText" placeholder="Pega aqu√≠ el texto de conexi√≥n" />
        <button id="connectButton" class="btn btn-success">Conectar</button>
      </div>
    </div>
  </div>
<!-------
  <script>
    // Configuraci√≥n de la aplicaci√≥n
    const STORAGE_KEY = 'p2pChat_v1';
    const CHUNK_SIZE = 16 * 1024; // 16KB por chunk para archivos
    
    // Estado de la aplicaci√≥n
    let state = {
      profile: { 
        name: '', 
        deviceId: generateDeviceId() 
      },
      contacts: [],
      messages: [],
      connection: {
        pc: null,
        dc: null,
        connected: false
      }
    };
    
    // Referencias a elementos del DOM
    const chatBox = document.getElementById('chatBox');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    const fileInput = document.getElementById('fileInput');
    const sendFileButton = document.getElementById('sendFileButton');
    const contactList = document.getElementById('contactList');
    const newContactName = document.getElementById('newContactName');
    const addContactButton = document.getElementById('addContactButton');
    const connectionText = document.getElementById('connectionText');
    const connectButton = document.getElementById('connectButton');
    const connectionStatus = document.getElementById('connectionStatus');
    const connectionInfo = document.getElementById('connectionInfo');
    const qrCode = document.getElementById('qrCode');
    
    // Cargar estado desde localStorage
    function loadState() {
      try {
        const savedState = localStorage.getItem(STORAGE_KEY);
        if (savedState) {
          state = JSON.parse(savedState);
        }
      } catch (e) {
        console.warn('Error al cargar estado:', e);
      }
      updateUI();
    }
    
    // Guardar estado en localStorage
    function saveState() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }
    
    // Generar ID de dispositivo √∫nico
    function generateDeviceId() {
      return 'device_' + Math.random().toString(36).substr(2, 9);
    }
    
    // Formatear fecha
    function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    }
    
    // Agregar mensaje al chat
    function addMessage(text, isSent, type = 'text') {
      const id = Date.now().toString();
      const timestamp = new Date().toISOString();
      
      const message = {
        id,
        text,
        isSent,
        type,
        timestamp
      };
      
      state.messages.push(message);
      saveState();
      renderChat();
    }
    
    // Renderizar chat
    function renderChat() {
      chatBox.innerHTML = '';
      
      state.messages.forEach(msg => {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${msg.isSent ? 'sent' : 'received'}`;
        
        if (msg.type === 'file') {
          messageDiv.innerHTML = `
            <div>${msg.text}</div>
            <span class="timestamp">${formatDate(msg.timestamp)}</span>
          `;
        } else {
          messageDiv.innerHTML = `
            <div>${msg.text}</div>
            <span class="timestamp">${formatDate(msg.timestamp)}</span>
          `;
        }
        
        chatBox.appendChild(messageDiv);
      });
      
      chatBox.scrollTop = chatBox.scrollHeight;
    }
    
    // Agregar mensaje de sistema
    function addSystemMessage(text) {
      addMessage(text, false, 'system');
    }
    
    // Actualizar UI
    function updateUI() {
      // Actualizar nombre de perfil
      if (!state.profile.name) {
        state.profile.name = 'Usuario ' + state.profile.deviceId.slice(0, 6);
        saveState();
      }
      
      // Actualizar estado de conexi√≥n
      if (state.connection.connected) {
        connectionStatus.textContent = 'Conectado';
        connectionStatus.style.color = '#2ecc71';
      } else {
        connectionStatus.textContent = 'Desconectado';
        connectionStatus.style.color = '#e74c3c';
      }
      
      // Renderizar contactos
      renderContacts();
      
      // Renderizar chat
      renderChat();
    }
    
    // Renderizar contactos
    function renderContacts() {
      contactList.innerHTML = '';
      
      if (state.contacts.length === 0) {
        contactList.innerHTML = '<p>No hay contactos a√∫n</p>';
        return;
      }
      
      state.contacts.forEach(contact => {
        const contactDiv = document.createElement('div');
        contactDiv.className = 'contact-item';
        contactDiv.innerHTML = `
          <div class="contact-info">
            <div class="contact-name">${contact.name}</div>
            <div class="contact-id">${contact.deviceId}</div>
          </div>
          <div class="contact-actions">
            <button onclick="removeContact('${contact.deviceId}')">Eliminar</button>
          </div>
        `;
        contactList.appendChild(contactDiv);
      });
    }
    
    // Agregar contacto
    function addContact() {
      const name = newContactName.value.trim();
      if (!name) return;
      
      const contact = {
        name,
        deviceId: generateDeviceId(),
        createdAt: new Date().toISOString()
      };
      
      state.contacts.push(contact);
      saveState();
      renderContacts();
      newContactName.value = '';
    }
    
    // Eliminar contacto
    function removeContact(deviceId) {
      state.contacts = state.contacts.filter(c => c.deviceId !== deviceId);
      saveState();
      renderContacts();
    }
    
    // Crear conexi√≥n WebRTC
    function createConnection() {
      try {
        // Configuraci√≥n de STUN/TURN
        const config = {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        };
        
        // Crear conexi√≥n RTCPeerConnection
        state.connection.pc = new RTCPeerConnection(config);
        
        // Manejar candidatos ICE
        state.connection.pc.onicecandidate = (event) => {
          if (event.candidate) {
            // Enviar candidato al otro lado (en una implementaci√≥n real, esto se har√≠a mediante se√±alizaci√≥n)
            console.log('Candidato ICE:', event.candidate);
          }
        };
        
        // Manejar datos entrantes
        state.connection.pc.ondatachannel = (event) => {
          state.connection.dc = event.channel;
          setupDataChannel();
        };
        
        // Manejar estado de conexi√≥n
        state.connection.pc.onconnectionstatechange = () => {
          console.log('Estado de conexi√≥n:', state.connection.pc.connectionState);
          if (state.connection.pc.connectionState === 'connected') {
            state.connection.connected = true;
            addSystemMessage('Conectado con √©xito');
            updateUI();
          } else if (state.connection.pc.connectionState === 'disconnected') {
            state.connection.connected = false;
            addSystemMessage('Conexi√≥n perdida');
            updateUI();
          }
        };
        
        // Crear canal de datos
        state.connection.dc = state.connection.pc.createDataChannel('chat');
        setupDataChannel();
        
        // Crear oferta
        state.connection.pc.createOffer()
          .then(offer => state.connection.pc.setLocalDescription(offer))
          .then(() => {
            // En una implementaci√≥n real, enviar esta oferta a trav√©s de se√±alizaci√≥n
            const offerJson = state.connection.pc.localDescription.toJSON();
            connectionInfo.textContent = 'Oferta generada. Comparte este texto con otro usuario.';
            // Mostrar QR o texto de conexi√≥n
            showConnectionInfo(offerJson);
          })
          .catch(err => {
            console.error('Error al crear oferta:', err);
            addSystemMessage('Error al crear conexi√≥n: ' + err.message);
          });
      } catch (err) {
        console.error('Error al crear conexi√≥n:', err);
        addSystemMessage('Error al crear conexi√≥n: ' + err.message);
      }
    }
    
    // Configurar canal de datos
    function setupDataChannel() {
      if (!state.connection.dc) return;
      
      state.connection.dc.binaryType = 'arraybuffer';
      
      state.connection.dc.onopen = () => {
        state.connection.connected = true;
        addSystemMessage('Conexi√≥n establecida');
        updateUI();
      };
      
      state.connection.dc.onclose = () => {
        state.connection.connected = false;
        addSystemMessage('Conexi√≥n cerrada');
        updateUI();
      };
      
      state.connection.dc.onmessage = (event) => {
        if (typeof event.data === 'string') {
          try {
            const parsed = JSON.parse(event.data);
            if (parsed.type === 'chat') {
              addMessage(parsed.text, false);
            } else if (parsed.type === 'file-meta') {
              // Manejar archivo entrante
              addSystemMessage(`Archivo recibido: ${parsed.fileName}`);
            } else {
              console.log('Mensaje de control:', parsed);
            }
          } catch (err) {
            console.warn('Error al parsear mensaje:', err);
          }
        } else {
          console.log('Mensaje binario recibido');
        }
      };
    }
    
    // Enviar mensaje
    function sendMessage() {
      const text = messageInput.value.trim();
      if (!text || !state.connection.connected) return;
      
      try {
        const message = {
          type: 'chat',
          text: text,
          timestamp: new Date().toISOString()
        };
        
        state.connection.dc.send(JSON.stringify(message));
        addMessage(text, true);
        messageInput.value = '';
      } catch (err) {
        console.error('Error al enviar mensaje:', err);
        addSystemMessage('Error al enviar mensaje: ' + err.message);
      }
    }
    
    // Enviar archivo
    function sendFile() {
      const file = fileInput.files[0];
      if (!file || !state.connection.connected) return;
      
      try {
        // Enviar metadatos del archivo
        const fileMeta = {
          type: 'file-meta',
          fileName: file.name,
          size: file.size,
          timestamp: new Date().toISOString()
        };
        
        state.connection.dc.send(JSON.stringify(fileMeta));
        
        // Enviar archivo en fragmentos
        const reader = new FileReader();
        let offset = 0;
        
        const sendChunk = () => {
          if (offset >= file.size) return;
          
          const slice = file.slice(offset, offset + CHUNK_SIZE);
          reader.readAsArrayBuffer(slice);
        };
        
        reader.onload = (e) => {
          state.connection.dc.send(e.target.result);
          offset += CHUNK_SIZE;
          sendChunk();
        };
        
        sendChunk();
        
        // Enviar se√±al de finalizaci√≥n
        state.connection.dc.send(JSON.stringify({
          type: 'file-end',
          fileName: file.name
        }));
        
        addMessage(`üìÅ Archivo enviado: ${file.name}`, true);
        fileInput.value = '';
      } catch (err) {
        console.error('Error al enviar archivo:', err);
        addSystemMessage('Error al enviar archivo: ' + err.message);
      }
    }
    
    // Mostrar informaci√≥n de conexi√≥n
    function showConnectionInfo(offerJson) {
      // En una implementaci√≥n real, aqu√≠ se mostrar√≠a un QR o texto para compartir
      connectionInfo.textContent = JSON.stringify(offerJson, null, 2);
      
      // Generar QR (simplificado)
      qrCode.innerHTML = `
        <div style="background:white; padding:10px; border-radius:5px;">
          <p style="font-size:12px; margin:0;">Comparte este c√≥digo con otro usuario:</p>
          <pre style="font-size:10px; margin:5px 0; overflow:auto;">${JSON.stringify(offerJson, null, 2)}</pre>
        </div>
      `;
    }
    
    // Conectar con texto de conexi√≥n
    function connectWithText() {
      const connectionTextValue = connectionText.value.trim();
      if (!connectionTextValue) return;
      
      try {
        const offer = JSON.parse(connectionTextValue);
        
        // Crear conexi√≥n
        const config = {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        };
        
        state.connection.pc = new RTCPeerConnection(config);
        state.connection.pc.onicecandidate = (event) => {
          if (event.candidate) {
            console.log('Candidato ICE:', event.candidate);
          }
        };
        
        state.connection.pc.ondatachannel = (event) => {
          state.connection.dc = event.channel;
          setupDataChannel();
        };
        
        state.connection.pc.onconnectionstatechange = () => {
          console.log('Estado de conexi√≥n:', state.connection.pc.connectionState);
          if (state.connection.pc.connectionState === 'connected') {
            state.connection.connected = true;
            addSystemMessage('Conectado con √©xito');
            updateUI();
          } else if (state.connection.pc.connectionState === 'disconnected') {
            state.connection.connected = false;
            addSystemMessage('Conexi√≥n perdida');
            updateUI();
          }
        };
        
        // Establecer la oferta remota
        state.connection.pc.setRemoteDescription(offer)
          .then(() => {
            // Crear respuesta
            return state.connection.pc.createAnswer();
          })
          .then(answer => {
            return state.connection.pc.setLocalDescription(answer);
          })
          .then(() => {
            // Enviar respuesta (en una implementaci√≥n real, esto se har√≠a mediante se√±alizaci√≥n)
            connectionInfo.textContent = 'Respuesta generada. Comparte esta respuesta con el otro usuario.';
            showConnectionInfo(state.connection.pc.localDescription.toJSON());
          })
          .catch(err => {
            console.error('Error al conectar:', err);
            addSystemMessage('Error al conectar: ' + err.message);
          });
      } catch (err) {
        console.error('Error al parsear conexi√≥n:', err);
        addSystemMessage('Error al parsear conexi√≥n: ' + err.message);
      }
    }
    
    // Eventos
    sendButton.addEventListener('click', sendMessage);
    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });
    
    sendFileButton.addEventListener('click', sendFile);
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        // Mostrar nombre de archivo
        addSystemMessage(`Seleccionado archivo: ${e.target.files[0].name}`);
      }
    });
    
    addContactButton.addEventListener('click', addContact);
    newContactName.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') addContact();
    });
    
    connectButton.addEventListener('click', connectWithText);
    
    // Inicializar aplicaci√≥n
    loadState();
    createConnection();
  </script>
</body>
</html>
<!--------

Caracter√≠sticas del chat P2P:
Conexi√≥n autom√°tica: El chat crea autom√°ticamente una conexi√≥n WebRTC usando STUN/TURN
Gesti√≥n de contactos: Puedes agregar contactos con nombres y se guardan localmente
Env√≠o de archivos: Puedes enviar archivos de cualquier tama√±o
Interfaz moderna: Dise√±o atractivo con gradientes y efectos visuales
Almacenamiento local: Todos los datos se guardan en localStorage del navegador
Indicador de conexi√≥n: Muestra el estado de la conexi√≥n en tiempo real



üî• Wow ‚Äî s√≠, este **ch

Perfecto üòé ‚Äî s√≠, puedo ayudarte a meter ese `script` (el `.js` o JSON) **sin romper tu HTML grande** de 800 l√≠neas.
Pero antes de hacerlo, necesito **ver una parte de tu archivo**, o saber **c√≥mo lo est√°s estructurando**.
Te explico por qu√© üëá

---

### üí° D√≥nde colocar el `<script>` en un HTML largo

Hay **3 lugares posibles** donde se puede poner un `<script>`:

1. **En el `<head>`**

   ```html
   <head>
     <script src="app.js"></script>
   </head>
   ```

   üî∏ Ideal si el JS **no depende del DOM** todav√≠a (solo inicializaciones, variables globales, etc.).

2. **Al final del `<body>` (recomendado)**

   ```html
   <body>
     ...
     <script src="app.js"></script>
   </body>
   ```

   ‚úÖ Este es el m√°s usado ‚Äî as√≠ el HTML carga primero, y luego el JS act√∫a sobre los elementos.

3. **En l√≠nea dentro del HTML**

   ```html
   <script>
     // c√≥digo directo aqu√≠
   </script>
   ```

   üî∏ √ötil si es solo un bloque peque√±o o temporal (pero en tu caso, no conviene mezclar m√°s).

---

### ‚öôÔ∏è Si quieres usar tambi√©n JSON o configuraci√≥n

Puedes incluirlo as√≠:

```html
<script id="config" type="application/json">
{
  "autoLoad": true,
  "repos": ["home", "online", "bius"],
  "mode": "sync"
}
</script>

<script src="main.js"></script>
```

Y en tu `main.js` puedes leerlo:

```js
const config = JSON.parse(document.getElementById('config').textContent);
console.log(config.autoLoad);
```

---

Entonces, para ayudarte **paso a paso y sin que se rompa nada**, necesito una de estas dos cosas:

1. üìÑ Que me pegues las **√∫ltimas 20‚Äì30 l√≠neas** de tu HTML (el final del `<body>` y el cierre del `<html>`),
   as√≠ te digo exactamente **d√≥nde insertar el `<script>`**.

**O**

2. Que me digas si tu archivo principal se llama, por ejemplo, `index.html`,
   y cu√°l es el archivo `.js` que quieres conectar (nombre o funci√≥n).

---

¬øMe pasas esa parte final de tu HTML (las √∫ltimas l√≠neas)?
As√≠ te marco **exactamente** d√≥nde copiar y pegar el script y el JSON.

# ia

------

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Web Dev Chatbot</title>
 <!---
 <link rel="stylesheet" href="style.css" />
 ------
 
  <style>
  
style.cssbody {
  margin: 0;
  padding: 0;
  font-family: 'Segoe UI', sans-serif;
  background: #1e1e1e;
  color: #fff;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}
.chat-container {
  width: 100%;
  max-width: 700px;
  padding: 20px;
}
h1 {
  text-align: center;
  color: #00ffd0;
  margin-bottom: 10px;
}
.chat-box {
  background: #2e2e2e;
  padding: 20px;
  border-radius: 10px;
  height: 500px;
  overflow-y: auto;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
}
.message {
  margin-bottom: 20px;
  line-height: 1.5;
}
.user {
  text-align: right;
  color: #00ffd0;
}
.bot {
  text-align: left;
  color: #eee;
}
pre {
  background: #111;
  padding: 10px;
  border-radius: 6px;
  overflow-x: auto;
  white-space: pre-wrap;
  word-break: break-word;
  color: #0f0;
  margin-top: 10px;
}
.input-group {
  display: flex;
  gap: 10px;
  margin-top: 10px;
}
textarea {
  flex: 1;
  padding: 12px;
  border-radius: 8px;
  border: none;
  background: #2e2e2e;
  color: #fff;
  font-size: 16px;
  resize: none;
  height: 60px;
}
button {
  background: #00ffd0;
  border: none;
  border-radius: 8px;
  padding: 0 20px;
  font-size: 24px;
  color: #000;
  cursor: pointer;
}
button:hover {
  background: #00c9a7;
}
</style>
</head>
<body>
  <div class="chat-container">
    <h1>üí¨ AI Web Dev Chatbot</h1>
    <div id="chatBox" class="chat-box"></div>
    
    <div class="input-group">
      <textarea id="userInput" placeholder="Ask anything"></textarea>
      <button onclick="sendMessage()">‚û§</button>
      <button onclick="startVoice()">üéôÔ∏è</button>
    </div>
  </div>
  
  <!-- JSZip & FileSaver for optional zip download later -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js

<script>
///script.js
const API_KEY = "AIzaSyDSIy5m7mTXlMMR_OOdCu2Af_EwoCd124w"; // Replace with your Gemini API Key
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;
const chatBox = document.getElementById("chatBox");
function sendMessage() {
  const input = document.getElementById("userInput");
  const userText = input.value.trim();
  if (!userText) return;
  
  addMessage("user", userText);
  input.value = "";
  getBotResponse(userText);
}
function addMessage(sender, text) {
  const msg = document.createElement("div");
  msg.className = `message ${sender}`;
  
  if (sender === "bot" && text.includes("```")) {
    const parsed = parseCode(text);
    msg.innerHTML = parsed;
  } else {
    msg.innerText = text;
  }
  
  chatBox.appendChild(msg);
  chatBox.scrollTop = chatBox.scrollHeight;
}
function parseCode(text) {
  return text.replace(/```(\w+)?([\s\S]*?)```/g, (_, lang, code) => {
    return `<pre><code>${escapeHtml(code.trim())}</code></pre>`;
  });
}
function escapeHtml(str) {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}
async function getBotResponse(prompt) {
  const thinking = document.createElement("div");
  thinking.className = "message bot";
  thinking.innerText = "Typing...";
  chatBox.appendChild(thinking);
  chatBox.scrollTop = chatBox.scrollHeight;
  
  try {
    const res = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
    });
    
    const data = await res.json();
    const aiText = data?.candidates?.[0]?.content?.parts?.[0]?.text || "‚ùå No response.";
    thinking.remove();
    addMessage("bot", aiText);
  } catch (err) {
    thinking.remove();
    addMessage("bot", "‚ö†Ô∏è Error getting response.");
  }
}
// Voice input
function startVoice() {
  const recognition = nw(window.SpeechRecognitio
    }}
    ;
